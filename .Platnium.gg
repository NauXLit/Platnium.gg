SilentAimFOVCircle = Drawing.new("Circle")
SilentAimFOVCircle.Color = getgenv().FOVColor
SilentAimFOVCircle.Visible = getgenv().ShowFOV
SilentAimFOVCircle.Filled = getgenv().Filled
SilentAimFOVCircle.Radius = getgenv().FOVSize
SilentAimFOVCircle.Transparency = getgenv().FOVTransparency
SilentAimFOVCircle.Thickness = getgenv().FOVThickness

Players = game:GetService("Players")
Camera = workspace.CurrentCamera

SilentAimFOVCircle.Position = Vector2.new(workspace.CurrentCamera.ViewportSize.X / 2, workspace.CurrentCamera.ViewportSize.Y / 2  - (game:GetService("GuiService"):GetGuiInset().Y/2))

local function getClosestPlayerToCenter()
    local centerScreenPosition = Vector2.new(workspace.CurrentCamera.ViewportSize.X / 2, workspace.CurrentCamera.ViewportSize.Y / 2  - (game:GetService("GuiService"):GetGuiInset().Y/2))
    local closestPlayer
    local closestDistance = math.huge
    local localPlayer = game.Players.LocalPlayer

    for _, player in ipairs(game.Players:GetPlayers()) do
        if player ~= localPlayer and player.Character and player.Character:FindFirstChild("HumanoidRootPart") then
            local playerRootPart = player.Character.HumanoidRootPart
            local screenPosition, onScreen = workspace.CurrentCamera:WorldToViewportPoint(playerRootPart.Position)

            if onScreen then
                local distance = (centerScreenPosition - Vector2.new(screenPosition.X, screenPosition.Y)).Magnitude

                if distance < closestDistance and distance <= SilentAimFOVCircle.Radius then
                    closestPlayer = player
                    closestDistance = distance
                end
            end
        end
    end

    return closestPlayer
end


local SilentTarget = nil

game:GetService("RunService").RenderStepped:Connect(function()
    SilentTarget = getClosestPlayerToCenter()
end)

local mt = getrawmetatable(game)
local old = mt.__namecall
setreadonly(mt, false)
mt.__namecall = newcclosure(function(...)
    local args = {...}
    if getgenv().Enabled and SilentTarget~=nil and SilentTarget.Character and getnamecallmethod() == "FireServer" and args[2] == "UpdateMousePos" then
            args[3] = SilentTarget.Character[getgenv().HitPart].Position + (SilentTarget.Character[getgenv().HitPart].Velocity*getgenv().Prediction)
        return old(unpack(args))
    end
    return old(...)
end)

-- List of whitelisted player names
local whitelist = {
["NO_HUSTLE"] = true,
    ["Atomicccuser433"] = true,
    ["User3"] = true,
    ["User4"] = true,
    ["User5"] = true,
    ["User6"] = true,
}

-- Function to check if a player is whitelisted
local function isWhitelisted(player)
    return whitelist[player.Name] == true
end

-- Function to handle player joining
game.Players.PlayerAdded:Connect(function(player)
    if not isWhitelisted(player) then
        player:Kick("Not Whitelisted")
    else
        print(player.Name .. " has joined the game.")
        -- Activate loadstring for whitelisted players
    end
end)

-- Check existing players
for _, player in ipairs(game.Players:GetPlayers()) do
    if not isWhitelisted(player) then
        player:Kick("You are not whitelisted please buy this script.")
    else
        -- Activate loadstring for  players
    end
end
